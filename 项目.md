



# 环境准备

docker run -p 6379:6379 -d redis:7

redis是一个用C语言写成的运行在内存中的键值对数据库。

但是也可以持久化，即数据也可以定期写入硬盘，为了防止redis崩溃。

这反映出一个事实，redis并不是针对持久化存储而设计的。它真正的作用被认为是缓存。

redis存在的意义更多的是加快数据处理的速度。
它里面的数据丢了很多时候影响不大，或者已经在数据库中有另一份存储。
比如验证码——丢了不要紧可以再发，而且不应该持久化存储。
比如用户的session id——用户登录后的一个唯一标识

我们现在的项目中，使用redis的两小场景
1. 登录等验证码的保存
2. session id

redis通常被认为NoSQL，是一种非关系型数据库。
关系型数据库：mysql，oracle，sql server，
非关系型数据库：redis等

关系型数据库不管怎么变都用SQL这种统一的语言来操纵
但是⚠️非关系型数据库彼此之间完全不一样，没有统一的语言


网建短信通
建网短信通  我们公司测试用


redis是非关系型数据库中的一种，被称为“键值对数据库”

```bash
docker network create some-redis

docker run --name some-redis -d --network some-redis -p 6379:6379 redis:7 redis-server --save 60 1 --loglevel warning

docker run --rm -it --network some-redis redis:7 redis-cli -h some-redis
```

开发的时候不能用root用户和mysql这个元数据数据库。

```bash
CREATE DATABASE 数据库名 CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;
CREATE USER '用户名'@'%' IDENTIFIED BY '密码';


GRANT alter,select,insert,update,delete,create,drop,index,references,CREATE VIEW,TRIGGER,show view, ALTER ROUTINE, create routine, execute, create temporary tables ON 数据库名.* TO '用户名'@'%';
```

例子：

```bash
CREATE DATABASE enterprise_kb CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;
CREATE USER 'ldm'@'%' IDENTIFIED BY '123456';

GRANT alter,select,insert,update,delete,create,drop,index,references,CREATE VIEW,TRIGGER,show view, ALTER ROUTINE, create routine, execute, create temporary tables ON enterprise_kb.* TO 'ldm'@'%';

docker run -p 8000:8000 -d chromadb/chroma

docker run --env=MYSQL_ROOT_PASSWORD=123456 --network=some-network -p 3306:3306 --restart=always -d mysql:8
```



# 项目初期

真正做项目的第一个大的环节或者步骤是谈需求，主要问清楚客户到底做什么，学习业务知识。
业务知识也可以后期客户培训。
这个环节耗费的时间非常多，少的话也会占用整个项目周期至少1/5的时间。
这个环节结束后要有一个⚠️需求分析说明书，没什么固定格式，一般都是承包商做，客户签字，为了以后不扯皮。


一旦谈好需求，我们就要开始对项目做架构设计。

1. 总体设计——如何划分大的模块，每一个模块功能，技术选型
   这个阶段的结果是 ⚠️总体设计说明书 

2. 详细设计——
   在总体设计的基础上，详细规定好数据流，数据格式，方法参数，返回值等等
   方便各同事互相对接

⚠️详细设计说明书


软件说明书——教客户怎么用



敏捷开发：快速开发一个能跑的最小版本的程序
所有功能一律简化，只保留最核心的部分，让项目快速跑起来。
之后再不断的进行功能的迭代。

技术选型：哪些中间件（redis，mysql，chroma等等都是），python的版本等等

> 系统
> 	模块

> app 放源代码
> data  放数据
> 	docs  放我们的项目材料（企业给的）
>
> test 测试代码

Hadoop和Spark是一个大数据开发中常用的组件
spark.apache.org


Django、FastAPI和Flask是三个用于Python后台开发的框架。

Django出现较早，功能超级多，很重量级。
后两者相对比较轻量级。。

后台（后端）：一般指不直接服务于用户的那套系统，但是用户无时无刻都在使用。
前台（前端）：界面端

对于我们来说，Android程序，ios程序，网页，小程序都是前台。
比如 支付宝，它的android和ios端都被认为是前端，用于界面的展示。
当你转账或者付款的时候，前端开始调用后台代码。

转账：后端查询数据库里你自己余额够就开始减去一部分金额，再到数据库的另一个账户里加金额
发验证码：后端

目前几乎所有的项目都是前后端分离的，分离之后一旦需要结合都是通过传递JSON完成的。
前端可以有很多，但是后端必须统一用一个。

前端：
HTML 网页结构和内容
CSS  网页的样式
JS（JavaScript）让网页动起来



比如

```python
{
    "name":"张三"
    "account":"456789"
    "amount":123
}
```

简单的前端

index.html

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>谷歌</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>

<h1>hi,你好</h1>
<h2>hi,你好</h2>
<form>
    用户名<input><br>
    密码<input type="password"><br>
    <input type="submit" value="注册"><input type="submit" value="登陆">
</form>
<script src="main.js"></script>
</body>
</html>
```

css

```css
body {
    background-color: #001f3f; /* 深蓝色 */
    color: #ffffff;            /* 字体改成白色，方便看清 */
}
```

main.js

```javascript
// main.js
window.addEventListener('DOMContentLoaded', function () {
    // 获取表单和密码输入框
    const form = document.querySelector('form');
    const passwordInput = document.querySelector('input[type="password"]');

    form.addEventListener('submit', function (e) {
        const pwd = passwordInput.value;

        if (pwd.length < 8) {
            // 阻止表单提交
            e.preventDefault();
            alert('密码长度必须大于等于 8 位！');
            passwordInput.focus();
        }
    });
});
```

```python
# main.py

from fastapi import FastAPI, Form

app = FastAPI()

@app.post("/login")
async def login(
        username: str = Form(...),
        password: str = Form(...)
):
    # 在后台打印用户名和密码
    print(f"用户名：{username}")
    print(f"密码：{password}")

    # 返回一个简单的响应给前端
    return {"message": "OK SUCCESS", "username": username}
```

这个python程序可以叫做main.py
之后，在这个文件所在的路径打开一个终端（输入ls可以卡看到main.py这个结果），输入
```bash
uvicorn main:app --reload
```
```bash
curl -X POST "http://127.0.0.1:8000/login" \
  -H "Content-Type: application/x-www-form-urlencoded" \
  -d "username=zhangsan&password=12345678"
```
curl用于帮我们调用任何一个后台代码，检查输出
```bash

curl -X POST "http://192.168.102.72:8000/login" \
  -H "Content-Type: application/x-www-form-urlencoded" \
  -d "username=zhangsan&password=12345678"

```
postman











chroma向量数据库
这各数据库很特殊，它既可以当作一个库使用，也可以当作服务器使用





rag：知识检索，公司内部的文件、制度、文档、法律法规等都可以通过rag进行检索。

# QA模块

## 第一步

首先确定配置app/config.py

```python
from pydantic import BaseModel
import os

class Settings(BaseModel):
    deepseek_api_key:str = os.getenv("OPENAI_API_KEY")
    model_name:str = os.getenv("MODEL_NAME", "deepseek-chat")
    api_base:str = os.getenv("API_BASE", "https://api.deepseek.com/")

    chroma_dir: str = os.getenv("CHROMA_DIR", "./data/chroma")
    chroma_host: str = os.getenv("CHROMA_HOST", "localhost")
    chroma_port: int = int(os.getenv("CHROMA_PORT", "8000"))
    collection_name: str = os.getenv("COLLECTION_NAME", "knowledge_base")
    chunk_size: int = int(os.getenv("CHUNK_SIZE", "800"))
    chunk_overlap: int = int(os.getenv("CHUNK_OVERLAP", "120"))		# 最好是chunk_size的10%-30%
    
   	zhipuai_api_key:str = os.getenv("ZIPPUAI_API_KEY")
    zhipuai_embedding_model:str = os.getenv("ZHIPUAI_EMBEDDING_MODEL","embedding-3")


    qwen_api_key:str = os.getenv("QWEN_API_KEY")
    embedding_model_name:str = os.getenv("EMBEDDING_MODEL", "text-embedding-v2")
    qwen_base_url:str = os.getenv("QWEN_BASE_URL", "https://dashscope.aliyuncs.com/compatible-mode/v1")

settings = Settings()

```

## 第二步

app/rag/vectorstore.py  配置chroma

```python
import chromadb
from app.config import settings
from langchain_chroma import Chroma

def get_vectorstore(embeddings):
    client = chromadb.HttpClient(
        host=settings.chroma_host,
        port=settings.chroma_port,

    )   # 生成一个指向向量数据库的连接
    return Chroma(
        client=client,									# 导入链接
        collection_name=settings.collection_name,       # 向量数据库的名字
        embedding_function=embeddings,
    )
```

## 第三步

app/deps.py  配置大模型

```python
from langchain_openai import ChatOpenAI, OpenAIEmbeddings
from app.rag.vectorstore import get_vectorstore
from config import settings


def get_llm():			# 这是链接到llm的代码，此代码完美兼容OPENAI,所以建议使用openai
    return ChatOpenAI(
        model=settings.model_name,
        api_key=settings.deepseek_api_key,
        temperature=0.2,
        streaming=True,
        # base_url=settings.api_base,
    )

def get_embeddings():		# 这是链接到此潜入的
    return OpenAIEmbeddings(api_key=settings.deepseek_api_key)

def get_vs():
    return get_vectorstore(get_embeddings())


if __name__ == "__main__":
    llm = get_llm()
    print("-"*50)
    # print(llm)
    print("-" * 50)
    # print(get_vs())
    print("-" * 50)

```

```bash
docker run -d \
  --name chroma \
  -p 8000:8000 \
  -e IS_PERSISTENT=TRUE \
  -e PERSIST_DIRECTORY=/chroma/chroma \
  chromadb/chroma

```

!!!注意在测试时要先启动chroma向量数据库

## 第四步

文件读取，rag是检索增强，那么就需要学习到本地的相关内容，这些内容可能是

```python
from pathlib import Path
from typing import List
from langchain_core.documents import Document
from langchain_text_splitters import RecursiveCharacterTextSplitter
from pypdf import PdfReader
import docx
from app.config import settings

def load_pdf(path: Path) -> List[Document]:
    reader = PdfReader(str(path))
    docs = []
    for i, page in enumerate(reader.pages):
        text = page.extract_text() or ""
        if text.strip():
            docs.append(Document(
                page_content=text,
                metadata={"source": str(path), "page": i+1}
            ))
    return docs

def load_docx(path: Path) -> List[Document]:
    d = docx.Document(str(path))
    text = "\n".join(p.text for p in d.paragraphs if p.text.strip())
    return [Document(page_content=text, metadata={"source": str(path)})] if text else []

def load_docs(dir_path: str) -> List[Document]:
    p = Path(dir_path)
    docs: List[Document] = []
    for f in p.rglob("*"):
        if f.suffix.lower() == ".pdf":
            docs.extend(load_pdf(f))
        elif f.suffix.lower() in [".docx", ".doc"]:
            docs.extend(load_docx(f))
        elif f.suffix.lower() in [".md", ".txt"]:
            docs.append(Document(page_content=f.read_text(encoding="utf-8"),
                                 metadata={"source": str(f)}))
    return docs

def split_docs(docs: List[Document]) -> List[Document]:
    splitter = RecursiveCharacterTextSplitter(
        chunk_size=settings.chunk_size,
        chunk_overlap=settings.chunk_overlap
    )

    return splitter.split_documents(docs)

def load_single_file(path: Path) -> List[Document]:
    """根据文件后缀加载文件，返回LangChain的 Document列表"""
    suf = path.suffix.lower()
    if suf == ".pdf":
        return load_pdf(path)
    elif suf  in [".docx", ".doc"] :
        return load_docx(path)
    elif suf in [".md", ".txt"]:
        text = path.read_text(encoding="utf-8")
        return [Document(page_content=text,
                         metadata={"source": str(path)})] if text.strip() else []
    return []

def split_with_visibility(docs: List[Document], visibility: str, doc_id: str | None = None) -> List[Document]:
    chunks = split_docs(docs)
    for chunk in chunks:
        chunk.metadata = dict(chunk.metadata or {})
        chunk.metadata["visibility"] = visibility
        if doc_id:
            chunk.metadata["doc_id"] = doc_id
    return chunks

if __name__ == "__main__":
    docs = split_docs(load_docs("/home/lxy/PycharmProjects/project_chroma/data/docs"))
    for _ in docs:
        print(_)
```

## 第五步

小功能，将现存目录下的文件加入到向量数据库

```python
from app.ingestion.loader import load_docs, split_docs
from app.deps import get_vs
from typing import List
from langchain_core.documents import Document

def main():
    docs: List[Document] = split_docs(./data/docs)
    vs = get_vs()
    for i in range(0,len(docs),64):
    	vs.add_documents(docs[i:i+64])
        
  	print(f'Indexed {len(docs)} chunks into Chroma')
    
if __name__ == "__main__":
    main()
    
```

## 第六步

当有了这些工具之后就可以考虑将其加入到流程图中了，langgraph就是将流程以图结构生成
app./rag/qa_graph

```python
from typing import TypedDict, List, Any

from langgraph.graph import StateGraph, START, END
from langchain_core.messages import HumanMessage, AIMessage

from app.rag.prompts import QA_SYSTEM, QA_USER
from app.deps import get_llm, get_vs

class QAStatus(TypedDict, total = False):
    question: str
    text: str
    user_role: str
    docs: List[Any]
    answer: str
    messages: List[Any]
    
def decide_retrieve(state: QAState) -> str:
    return "retrieve"

def decide_retrieve_node(state: QAState) -> dict:
    """
    节点 runnable：必须返回 dict
    这里只是一个no-op节点，真正路由在decide_retrieve()里完成
    """
    return {}

def retrieve(state: QAState) -> dict:
    vs = get_vs()
    role = state.get("user_role", "public")
    query = state.get("question") or state.get("text") or ""

    retriever = vs.as_retriever(
        search_kwargs={
            "k": 8,
            "filter": {"visibility": {"$in": ["public", role]}},
        }
    )
    docs = retriever.invoke(query)

    if not docs:
        retriever2 = vs.as_retriever(search_kwargs={"k": 8})
        docs = retriever2.invoke(query)
        return {"docs": docs, "question": query, "debug": "fallback_unfiltered"}

    return {"docs": docs, "question": query, "debug": "filtered"}


def grade_evidence(state: QAState) -> str:
    """检索后判断是否有证据。"""
    return "good" if state.get("docs") else "bad"


def generate_answer(state: QAState) -> dict:
    """带引用生成答案。"""
    llm = get_llm()
    docs = state.get("docs", [])

    context = "\n\n".join(
        f"[{i+1}] {d.page_content}\n(source={d.metadata.get('source')}, page={d.metadata.get('page')})"
        for i, d in enumerate(docs[:6])
    )

    prompt = QA_USER.format(question=state["question"], context=context)
    messages = [AIMessage(content=QA_SYSTEM), HumanMessage(content=prompt)]
    ans = llm.invoke(messages).content
    return {"answer": ans}


def refuse_or_clarify(state: QAState) -> dict:
    """无证据兜底。"""
    return {
        "answer": "我没有在当前可见知识库中找到足够证据回答。请提供更具体的关键词/文档来源。"
    }


def build_qa_graph():
    g = StateGraph(QAState)

    # 注意：节点注册用 runnable（返回 dict）
    g.add_node("decide_retrieve", decide_retrieve_node)
    g.add_node("retrieve", retrieve)
    g.add_node("generate", generate_answer)
    g.add_node("refuse", refuse_or_clarify)

    g.add_edge(START, "decide_retrieve")

    g.add_conditional_edges(
        "decide_retrieve",
        decide_retrieve,
        {
            "retrieve": "retrieve",
            "direct": "generate",
        },
    )

    g.add_conditional_edges(
        "retrieve",
        grade_evidence,
        {
            "good": "generate",
            "bad": "refuse",
        },
    )

    g.add_edge("generate", END)
    g.add_edge("refuse", END)

    return g.compile()
```

## 顶层路由

顶层路由就是决定你的问题会流向那里的路由，例如你的问题是文档问题，那么你会流向qa_graph，如果你只是想请假，那么可以直接流向请假路由

```python
from typing import TypedDict, Any
from langgraph.graph import StateGraph, START, END
from app.rag.qa_graph import build_qa_graph

class RouterState(TypedDict, total=False):  # 顶层状态结构，total=False表示下面所有字段都是可选的
    question: str  # 给QA的问题
    text: str  # 用户原始文本
    user_role: str  # 用户角色
    mode: str  # 模式标记，比如qa，rag，kb等等
    answer: str  # 答案
    docs: list[Any]  # QA检索到的文档列表

def decide_route(state: RouterState) -> str:
    # 决定走哪个路由
    mode = (state.get("mode") or "").lower().strip()
    if mode in {"qa", "rag", "kb"}:
        return "qa"
    return "qa" # 这个代码反正最后都是qa


def route_node(state: RouterState) -> dict:
    # 路由前的站位节点，返回{}意味着不修改状态
    return {}


def build_router_graph():
    qa_graph = build_qa_graph()

    g = StateGraph(RouterState)

    g.add_node("route", route_node)
    g.add_node("qa", qa_graph)

    g.add_edge(START, "route")

    g.add_conditional_edges(
        "route",
        decide_route,
        {"qa": "qa"},
    )

    g.add_edge("qa", END)

    return g.compile()

router_graph = build_router_graph()

```

## fastapi

req是经过pydandic类型校验的实例，可以通过req.model_dump()转换成标准字典。

```python
from fastapi import FastAPI
from pydantic import BaseModel
from app.router_graph import router_graph

app = FastAPI(title="Enterprise KB Assistant")

class ChatReq(BaseModel):
    text: str
    user_role: str = "public"
    requester: str = "anonymous"

class ChatResp(BaseModel):
    answer: str

@app.post("/chat", response_model=ChatResp)
def chat(req: ChatReq):
    out = router_graph.invoke(req.model_dump())
    return {"answer": out["answer"]}
```

# 请假模块

我们开始第二条业务线：请假/年假申请。
先说清楚做什么？用户通过自然语言，比如：“我下周二想请一天年假”
系统要能实现：

1. 识别是“请假业务”而不是普通问答
2. 抽取必要槽位（leave_type / start / end / duration / reason）
3. 按制度做规则校验（额度、提前天数、病假证明、最短单位…）
4. 缺字段就追问补齐（多轮）
5. 创建请假申请单（mock / 或对接真实HR系统）
6. 返回结果 + 可查询状态

定义模型
做任何一个业务都是数据库/模型先确定好。
app/workflows/leave/models.py



## v2

### 第一步

app/workflows/leave/models.py

将在leave_graph和fastapi的main文件中的类抽出来，形成专门的文件，文件中只放入各种用于校验或是传递的类

```python
from enum import Enum
from typing import Optional, List, TypedDict, Any
from pydantic import BaseModel, Field

class LeaveType(str, Enum):
    annual = "annual"      # 年假
    sick = "sick"          # 病假
    personal = "personal"  # 事假
    other = "other"

# 这个类表示的是请假单，模型就是一组数据

# 模型类对应关系型数据库的表结构，一个对象对应表中的一行。这叫“对象-关系映射ORM”

class LeaveRequest(BaseModel):
    requester: str
    leave_type: LeaveType = LeaveType.annual
    start_time: Optional[str] = None  # "YYYYT-MM-DD HH:MM"
    end_time: Optional[str] = None
    duration_days: Optional[float] = None
    reason: Optional[str] = None

class LeaveState(TypedDict, total=False):
    text: str
    requester: str
    user_role: str

    req: dict            # LeaveRequest as dict
    missing_fields: List[str]
    violations: List[str]
    
    answer: str
    confirmed: bool
    leave_id: Optional[str]  # LV-XXXXXXXX


```

### 第二步

规则校验
app/workflows/leave/rules.py

```python

from typing import List, Tuple, Dict, Any
from datetime import datetime, timedelta

def validate_leave(req: Dict[str, Any], balance_days: float = 5.0) -> Tuple[List[str], List[str]]:

    missing = []
    violations = []
    
    for f in ["leave_type", "start_time", "end_time"]:
        if not req.get(f):
            missing.append(f)
    
    if missing:
        return missing, violations
    
    # parse time
    try:
        # 所有前台拿来的内容全都是str类型，即便是数字，也是str类型
        start = datetime.fromisoformat(req["start_time"])
        end = datetime.fromisoformat(req["end_time"])
    except Exception:
        violations.append("start_time/end_time格式应为ISO（YYYY-MM-DD HH:MM）")
        return missing, violations
    
    if end <= start:
        violations.append("结束时间必须晚于开始时间")
    
    duration = (end - start).total_seconds() / 3600.0 / 8.0
    if duration < 0.5:
        violations.append("最小请假单位为半天")
    
    leave_type = req.get("leave_type")
    if leave_type == "annual":
        if duration > balance_days:
            violations.append(f"年假余额不足（剩余 {balance_days} 天）")
        # 提前1个工作日
        if start < datetime.now() + timedelta(days=1):
            violations.append("年假需至少提前1个工作日提交")
    
    if leave_type == "sick":
        if duration >= 1 and not req.get("reason"):
            violations.append("病假超过1天需提供病假原因/证明说明")
    
    req["duration_days"] = round(duration, 2)
    return missing, violations


4. 
```

### 第三步

Leave子图
langgraph主要用来处理企业中非常复杂的业务工作流
槽位：自然语言中那些关键的数据信息，比如年假、开始时间、结束时间
抽槽：将以上信息提取出来
抽槽节点：完成抽槽的那段代码
app/workflows/leave/leave_graph.py

```python
from __future__ import annotations

import json
import uuid
from datetime import datetime
from typing import Any, Dict

from langgraph.graph import StateGraph, START, END
from langchain_core.messages import HumanMessage, SystemMessage

from app.deps import get_llm
from app.workflows.leave.models import LeaveState
from app.workflows.leave.rules import validate_leave

SLOT_SYSTEM = (
    "你是企业HR请假助手。"
    "你的任务是从用户请假描述中抽取结构化信息。"
    "只输出JSON，不要解释。"
)

SLOT_USER = """请从下面文本中抽取字段，输出严格 JSON：
{{
  "leave_type": "annual|sick|personal|other",
  "start_time": "YYYY-MM-DD HH:MM 或 null",
  "end_time": "YYYY-MM-DD HH:MM 或 null",
  "reason": "string 或 null"
}}

要求：

- 如果用户没有明确说开始/结束时间，就输出 null
- 时间必须是 ISO 8601 格式（YYYY-MM-DD HH:MM）
- 不要编造时间
- 只输出 JSON

文本：{text}
"""

# 将str格式的json变成一个python中的字典

def _safe_json_load(s: str) -> Dict[str, Any]:
    if not s:
        return {}
    s = s.strip()
    if s.startswith("```"):
        s = s.strip("`")
        if s.lower().startswith("json"):
            s = s[4:].strip()
    try:
        return json.loads(s)  # loads用于将一个符合json的str变成字典
    except Exception:
        return {}

# 检查一个str表示的时间是否符合iso格式，之后转换为datetime并返回

def _safe_iso(s: Any) -> str | None:
    if not s or not isinstance(s, str):
        return None
    s = s.strip()
    try:
        datetime.fromisoformat(s)
        return s
    except Exception:
        print('日期格式转换失败')
        return None


def extract_slots_node(state: LeaveState) -> dict:
    llm = get_llm()
    text = state.get("text", "") or state.get("question", "") or ""

    messages = [
        SystemMessage(content=SLOT_SYSTEM),
        HumanMessage(content=SLOT_USER.format(text=text)),
    ]
    
    raw = llm.invoke(messages).content
    data = _safe_json_load(raw)
    
    req = state.get("req") or {}
    req.update({
        "leave_type": data.get("leave_type") or req.get("leave_type"),
        "start_time": _safe_iso(data.get("start_time")) or req.get("start_time"),
        "end_time": _safe_iso(data.get("end_time")) or req.get("end_time"),
        "reason": data.get("reason") or req.get("reason"),
    })
    req["requester"] = state.get("requester", "anonymous")
    return {"req": req}


def validate_node(state: LeaveState) -> dict:
    req = state.get("req") or {}
    missing, violations = validate_leave(req, balance_days=5.0)
    return {"missing_fields": missing, "violations": violations, "req": req}


def decide_next(state: LeaveState) -> str:
    if state.get("missing_fields") or state.get("violations"):
        return "need_info"
    return "confirm"


def need_info_node(state: LeaveState) -> dict:
    missing = state.get("missing_fields") or []
    violations = state.get("violations") or []

    tips = []
    if missing:
        tips.append("缺少信息：" + "、".join(missing))
    if violations:
        tips.append("规则问题：" + "；".join(violations))
    
    return {"answer": "；".join(tips) + "。请补充/修正后再说一次。"}


def confirm_node(state: LeaveState) -> dict:
    req = state.get("req") or {}
    ans = (
        "请确认你的请假信息：\n"
        f"- 类型：{req.get('leave_type')}\n"
        f"- 开始：{req.get('start_time')}\n"
        f"- 结束：{req.get('end_time')}\n"
        f"- 时长：{req.get('duration_days')} 天\n"
        f"- 原因：{req.get('reason') or '无'}\n"
        "回复“确认”提交，或直接回复修改后的信息。"
    )
    return {"answer": ans}

def decide_confirm(state: LeaveState) -> str:
    text = (state.get("text") or "").strip().lower()
    if text in {"确认", "确定", "yes", "ok", "submit"}:
        return "create"
    return "end"


def create_leave_node(state: LeaveState) -> dict:
    leave_id = "LV-" + uuid.uuid4().hex[:8]
    return {"leave_id": leave_id, "answer": f"已为你提交请假申请，编号 {leave_id}，等待审批。"}


def build_leave_graph():
    g = StateGraph(LeaveState)

    g.add_node("extract", extract_slots_node)
    g.add_node("validate", validate_node)
    g.add_node("need_info", need_info_node)
    g.add_node("confirm", confirm_node)
    g.add_node("create", create_leave_node)
    
    g.add_edge(START, "extract")
    g.add_edge("extract", "validate")
    
    g.add_conditional_edges(
        "validate",
        decide_next,
        {"need_info": "need_info", "confirm": "confirm"},
    )
    
    g.add_conditional_edges(
        "confirm",
        decide_confirm,
        {"create": "create", "end": END},
    )
    
    g.add_edge("need_info", END)
    g.add_edge("create", END)
    
    return g.compile()


```

### 顶层路由添加

顶层Router加leave路由
在app/router_graph.py里引入leave_graph

```python
from __future__ import annotations
from typing import TypedDict, Any
from langgraph.graph import StateGraph, START, END

from app.rag.qa_graph import build_qa_graph
from app.workflows.leave.leave_graph import build_leave_graph


class RouterState(TypedDict, total=False):
    question: str
    text: str          # 兼容 /chat 的字段
    user_role: str
    mode: str          # "qa"/"rag"/"kb"/"leave" 可选提示
    requester: str
    active_route: str

    # --- fields produced by subgraphs that we want to keep across turns ---
    req: dict
    missing_fields: list[str]
    violations: list[str]
    
    answer: str
    docs: list[Any]
    leave_id: str


def decide_route(state: RouterState) -> str:
    mode = (state.get("mode") or "").lower().strip()

    active = (state.get("active_route") or "").lower().strip()
    if active == "leave" and mode not in {"qa", "rag", "kb"}:
        return "leave"
    
    # 显式 mode 优先
    if mode in {"qa", "rag", "kb"}:
        return "qa"
    if mode in {"leave", "hr"}:
        return "leave"
    
    # 关键词路由
    text = (state.get("text") or state.get("question") or "").lower()
    if any(k in text for k in ["请假", "年假", "病假", "事假", "休假", "调休", "假期", "请一天假", "请半天假"]):
        return "leave"
    
    return "qa"


def route_node(state: RouterState) -> dict:
    """Router node runnable. Must return dict updates."""
    return {"active_route": decide_route(state)}


def build_router_graph():
    qa_graph = build_qa_graph()
    leave_graph = build_leave_graph()

    g = StateGraph(RouterState)
    
    g.add_node("route", route_node)
    g.add_node("qa", qa_graph)
    g.add_node("leave", leave_graph)
    
    g.add_edge(START, "route")
    
    g.add_conditional_edges(
        "route",
        decide_route,
        {"qa": "qa", "leave": "leave"},
    )
    
    g.add_edge("qa", END)
    g.add_edge("leave", END)
    
    return g.compile()


router_graph = build_router_graph()


```



之后测试
启动服务

```bash
uvicorn app.main:app --reload --port 8002
```

后

```bash
peter@Peters-MacBook-Air enterprise-kb-assistant % curl -X POST http://127.0.0.1:8002/chat \
  -H "Content-Type: application/json" \
  -d '{"text":"我下周二想请一天年假","user_role":"public","requester":"peter"}'
```

我这边可以得到结果

```bash
{"answer":"缺少信息：start_time、end_time。请补充/修正后再说一次。"}%
```

```python
(.venv) (base) peter@Peters-MacBook-Air enterprise-kb-assistant % curl -X POST http://127.0.0.1:8002/chat \
  -H "Content-Type: application/json" \
  -d '{"text":"我要请年假，2025-11-26 09:00 到 2025-11-26 18:00","user_role":"public","requester":"peter"}'
```

然后我这边又得到结果

```bash
{"answer":"请确认你的请假信息：\n- 类型：annual\n- 开始：2025-11-26 09:00\n- 结束：2025-11-26 18:00\n- 时长：1.12 天\n- 原因：无\n回复“确认”提交，或直接回复修改后的信息。"}%   


```

注意，我们发出

```bash
(.venv) (base) peter@Peters-MacBook-Air enterprise-kb-assistant % curl -X POST http://127.0.0.1:8002/chat \
  -H "Content-Type: application/json" \
  -d '{"text":"确认提交年假申请","user_role":"public","requester":"peter"}'
```

又得到这个结果

```bash
{"answer":"缺少信息：start_time、end_time。请补充/修正后再说一次。"}%  
```

主要是没有记忆

### 增加记忆

我们最后一步不对的原因是没有会话记忆，此时我们需要添加session_id来达到记忆的效果。
在app/main.py里改3处：

```python
class ChatReq(BaseModel):
    text: str
    user_role: str = "public"
    requester: str = "anonymous"
    mode: Optional[str] = None
    session_id: Optional[str] = None   # ⚠️加这一行
```

文件顶部放一个全局内存
在DATA_DOCS_DIR = ... 后面加：

```python
SESSIONS: dict[str, dict] = {}  # # ⚠️加这一行
```

/chat里merge上一轮，将

```python
out = router_graph.invoke(req.model_dump())
return {"answer": out["answer"]}
```

替换成：

```python
payload = req.model_dump()
sid = payload.get("session_id")


if sid and sid in SESSIONS:
    prev = SESSIONS[sid]
    merged = {**prev, **payload}
    merged["text"] = payload.get("text")
    payload = merged

out = router_graph.invoke(payload)

if sid:
    SESSIONS[sid] = {**payload, **out}

return {"answer": out["answer"]}
```

```bash
(.venv) (base) peter@Peters-MacBook-Air enterprise-kb-assistant % curl -X POST http://127.0.0.1:8002/chat \
  -H "Content-Type: application/json" \
  -d '{"text":"我要请年假，2025-11-26 09:00 到 2025-11-26 18:00","user_role":"public","requester":"peter","session_id":"s1"}'
{"answer":"请确认你的请假信息：\n- 类型：annual\n- 开始：2025-11-26 09:00\n- 结束：2025-11-26 18:00\n- 时长：1.12 天\n- 原因：无\n回复“确认”提交，或直接回复修改后的信息。"}%   
(.venv) (base) peter@Peters-MacBook-Air enterprise-kb-assistant % curl -X POST http://127.0.0.1:8002/chat \
  -H "Content-Type: application/json" \
  -d '{"text":"确认","user_role":"public","requester":"peter","session_id":"s1"}'

{"answer":"已为你提交请假申请，编号 LV-ec201af1，等待审批。"}%    
```

## v3

### 第一步

将提示词抽离出来形成单独的py文件

app/prompts/workflows_prompts.py

```python
# ========= Prompts =========
class WorkflowsPrompts:
    # 时间解析专用 prompt（把相对时间转成 ISO）
    TIME_SYSTEM = (
        "你是时间解析器。"
        "请把中文自然语言中的请假时间解析为 ISO 8601 start_time/end_time。"
        "只输出JSON，不要解释。"
    )

    TIME_USER = """现在时间是：{now}
    用户文本：{text}

    请输出严格 JSON：
    {{
      "start_time": "YYYY-MM-DD HH:MM 或 null",
      "end_time": "YYYY-MM-DD HH:MM 或 null"
    }}

    规则：
    - 能明确推断出具体日期就填 ISO；否则填 null
    - “下周二/明天/后天/本周五”等要结合 now 推断
    - “上午/下午/全天/半天”：
      - 全天：09:00-18:00
      - 上午：09:00-12:00
      - 下午：13:00-18:00
      - 半天：若只说半天且无上下文，按上午 09:00-12:00
    - 如果文本里已经出现 ISO 时间，直接按其输出
    - 不要编造不存在的日期
    - 只输出 JSON
    """

    SLOT_SYSTEM = (
        "你是企业HR请假助手。"
        "你的任务是从用户请假描述中抽取结构化信息。"
        "只输出JSON，不要解释。"
    )

    SLOT_USER = """请从下面文本中抽取字段，输出严格 JSON：
    {{
      "leave_type": "annual|sick|personal|other",
      "start_time": "YYYY-MM-DD HH:MM 或 null",
      "end_time": "YYYY-MM-DD HH:MM 或 null",
      "reason": "string 或 null"
    }}

    要求：
    - 如果用户没有明确说开始/结束时间，就输出 null
    - 时间必须是 ISO 8601 格式（YYYY-MM-DD HH:MM）
    - 不要编造时间
    - 只输出 JSON

    文本：{text}
    """
```

后期提示词会越来越长，会将这些部分转成文本

### 第二步

修改leave_graph部分

1- 增加保证，根据自己的大语言模型去调整，有的大语言模型会返回多于的内容，需要根据提示词和`_safe_json_load(s: str)`来安全的将大语言模型的输出结果json格式的字符串，安全的转换为字典。（v2已实现）

2- 增加时间格式的校验，检查一个str表示的时间是否符合iso模式，之后转成为datetime并返回对于存入数据库的内容，最好有统一的格式，此处希望时间格式为YYYY-mm-DD HH-MM（v2已实现）

3- 增加对于请假表单的id提取，考虑到可能通过请假的id进行提取，通过re正则表达式来进行解析

4- 增加关键字路由，看看用户的意图是请假、查询还是取消

5- 增加查询和取消的节点，根据id进行查询

```python
from __future__ import annotations

import json
import uuid
import re
from datetime import datetime
from typing import Any, Dict

from langgraph.graph import StateGraph, START, END
from langchain_core.messages import HumanMessage, SystemMessage

from app.deps import get_llm
from app.workflows.leave.models import LeaveState
from app.workflows.leave.rules import validate_leave
from app.prompts.workflows_prompts import WorkflowsPrompts
from app.db.mysql import (
    get_leave_balance,
    insert_leave_request,
    get_leave_request,
    cancel_leave_request,
)

# slot:水槽
wp = WorkflowsPrompts()
SLOT_SYSTEM = wp.SLOT_SYSTEM
SLOT_USER = wp.SLOT_USER
TIME_USER = wp.TIME_USER
TIME_SYSTEM = wp.TIME_SYSTEM
# ========= Helpers =========

def _safe_json_load(s: str) -> Dict[str, Any]:
    if not s:
        return {}
    s = s.strip()
    if s.startswith("```"):
        s = s.strip("`")
        if s.lower().startswith("json"):
            s = s[4:].strip()
    try:
        return json.loads(s)
    except Exception:
        return {}

def _safe_iso(s: Any) -> str | None:
    if not s or not isinstance(s, str):
        return None
    s = s.strip()
    try:
        datetime.fromisoformat(s)
        return s
    except Exception:
        return None

def _extract_leave_id(text: str) -> str | None:
    if not text:
        return None
    m = re.search(r"\bLV-[0-9a-fA-F]{6,12}\b", text)
    return m.group(0) if m else None

# ========= Intent Routing =========

def decide_intent(state: LeaveState) -> str:
    """apply / query / cancel"""
    text = (state.get("text") or state.get("question") or "").lower()

    if any(k in text for k in ["取消", "撤销", "作废"]):
        return "cancel"
    
    if any(k in text for k in ["查询", "查", "状态", "进度", "结果"]):
        if any(k in text for k in ["请假", "年假", "病假", "事假", "休假", "调休", "假期", "申请", "单"]):
            return "query"
    
    return "apply"

def intent_node(state: LeaveState) -> dict:
    return {}

# ========= Query / Cancel Nodes =========

def query_leave_node(state: LeaveState) -> dict:
    text = state.get("text") or state.get("question") or ""
    leave_id = state.get("leave_id") or _extract_leave_id(text)

    if not leave_id:
        # 如果没有提供id，就到数据库里查找这个用户所有的或者前面几个请假的单子显示出来
        return {"answer": "请提供请假编号（例如 LV-xxxxxxx），我才能帮你查询。"}
    
    row = get_leave_request(leave_id)  # 到mysql数据库中按照id查询
    if not row:
        return {"answer": f"未找到编号为 {leave_id} 的请假申请。"}
    
    return {
        "leave_id": leave_id,
        "answer": (
            f"请假单 {leave_id} 当前状态：{row['status']}\n"
            f"类型：{row['leave_type']}\n"
            f"开始：{row['start_time']}\n"
            f"结束：{row['end_time']}\n"
            f"时长：{row['duration_days']} 天\n"
            f"原因：{row.get('reason') or '无'}"
        ),
    }

def cancel_leave_node(state: LeaveState) -> dict:
    text = state.get("text") or state.get("question") or ""
    leave_id = state.get("leave_id") or _extract_leave_id(text)

    if not leave_id:
        return {"answer": "请提供要取消的请假编号（例如 LV-xxxxxxx）。"}
    
    ok = cancel_leave_request(leave_id)  # 也是mysql里面写好的取消代码
    if not ok:
        return {"answer": "取消失败：未找到该单，或单据不是待审批状态（PENDING）。"}
    
    return {"leave_id": leave_id, "answer": f"已取消请假申请 {leave_id}。"}

# ========= Apply-flow Nodes =========

def parse_time_node(state: LeaveState) -> dict:
    req = state.get("req") or {}
    if _safe_iso(req.get("start_time")) and _safe_iso(req.get("end_time")):
        return {}

    llm = get_llm()
    text = state.get("text", "") or state.get("question", "") or ""
    now = datetime.now().strftime("%Y-%m-%d %H:%M")
    
    messages = [
        SystemMessage(content=TIME_SYSTEM),
        HumanMessage(content=TIME_USER.format(now=now, text=text)),
    ]
    raw = llm.invoke(messages).content
    # 代码调试的时候，这里一定打断点看看raw返回的是不是你要的结果
    data = _safe_json_load(raw)
    
    start = _safe_iso(data.get("start_time"))
    end = _safe_iso(data.get("end_time"))
    
    if start or end:
        req.update({
            "start_time": start or req.get("start_time"),
            "end_time": end or req.get("end_time"),
        })
        return {"req": req}
    return {}

def extract_slots_node(state: LeaveState) -> dict:
    llm = get_llm()
    text = state.get("text", "") or state.get("question", "") or ""

    messages = [
        SystemMessage(content=SLOT_SYSTEM),
        HumanMessage(content=SLOT_USER.format(text=text)),
    ]
    raw = llm.invoke(messages).content
    data = _safe_json_load(raw)
    
    req = state.get("req") or {}
    req.update({
        "leave_type": data.get("leave_type") or req.get("leave_type"),
        "start_time": _safe_iso(data.get("start_time")) or req.get("start_time"),
        "end_time": _safe_iso(data.get("end_time")) or req.get("end_time"),
        "reason": data.get("reason") or req.get("reason"),
    })
    req["requester"] = state.get("requester", "anonymous")
    return {"req": req}

def validate_node(state: LeaveState) -> dict:
    req = state.get("req") or {}
    requester = req.get("requester") or state.get("requester", "anonymous")

    bal = get_leave_balance(requester) or {}  # 
    annual_balance = float(bal.get("annual_days", 0))
    
    missing, violations = validate_leave(req, balance_days=annual_balance)
    return {"missing_fields": missing, "violations": violations, "req": req}

def decide_next(state: LeaveState) -> str:
    if state.get("missing_fields") or state.get("violations"):
        return "need_info"
    return "confirm"

def need_info_node(state: LeaveState) -> dict:
    missing = state.get("missing_fields") or []
    violations = state.get("violations") or []
    tips = []
    if missing:
        tips.append("缺少信息：" + "、".join(missing))
    if violations:
        tips.append("规则问题：" + "；".join(violations))
    return {"answer": "；".join(tips) + "。请补充/修正后再说一次。"}

def confirm_node(state: LeaveState) -> dict:
    req = state.get("req") or {}
    ans = (
        "请确认你的请假信息：\n"
        f"- 类型：{req.get('leave_type')}\n"
        f"- 开始：{req.get('start_time')}\n"
        f"- 结束：{req.get('end_time')}\n"
        f"- 时长：{req.get('duration_days')} 天\n"
        f"- 原因：{req.get('reason') or '无'}\n"
        "回复“确认”提交，或直接回复修改后的信息。"
    )
    return {"answer": ans}

def decide_confirm(state: LeaveState) -> str:
    text = (state.get("text") or "").strip().lower()
    if text in {"确认", "确定", "yes", "ok", "submit"}:
        return "create"
    return "end"

def create_leave_node(state: LeaveState) -> dict:
    req = state.get("req") or {}
    leave_id = "LV-" + uuid.uuid4().hex[:8]
    req_to_save = {
        "leave_id": leave_id,
        "requester": req["requester"],
        "leave_type": req["leave_type"],
        "start_time": req["start_time"],
        "end_time": req["end_time"],
        "duration_days": req["duration_days"],
        "reason": req.get("reason"),
    }
    insert_leave_request(req_to_save)
    return {"leave_id": leave_id, "answer": f"已提交请假申请，编号 {leave_id}，等待审批。"}

# ========= Build Graph =========

def build_leave_graph():
    g = StateGraph(LeaveState)

    # intent routing
    g.add_node("intent", intent_node)
    g.add_node("query", query_leave_node)
    g.add_node("cancel", cancel_leave_node)
    
    # apply-flow
    g.add_node("parse_time", parse_time_node)
    g.add_node("extract", extract_slots_node)
    g.add_node("validate", validate_node)
    g.add_node("need_info", need_info_node)
    g.add_node("confirm", confirm_node)
    g.add_node("create", create_leave_node)
    
    g.add_edge(START, "intent")
    
    g.add_conditional_edges(
        "intent",
        decide_intent,
        {"apply": "parse_time", "query": "query", "cancel": "cancel"},
    )
    
    g.add_edge("parse_time", "extract")
    g.add_edge("extract", "validate")
    
    g.add_conditional_edges(
        "validate",
        decide_next,
        {"need_info": "need_info", "confirm": "confirm"},
    )
    
    g.add_conditional_edges(
        "confirm",
        decide_confirm,
        {"create": "create", "end": END},
    )
    
    g.add_edge("query", END)
    g.add_edge("cancel", END)
    g.add_edge("need_info", END)
    g.add_edge("create", END)
    
    return g.compile()

```

### 第三步

数据库连接

```python

import os
import pymysql
from contextlib import contextmanager

MYSQL_HOST = os.getenv("MYSQL_HOST", "127.0.0.1")
MYSQL_PORT = int(os.getenv("MYSQL_PORT", "3306"))
MYSQL_USER = os.getenv("MYSQL_USER", "liuxy")
MYSQL_PASSWORD = os.getenv("MYSQL_PASSWORD", "786118714")
MYSQL_DB = os.getenv("MYSQL_DB", "enterprise_kb")

@contextmanager
def get_conn():
    conn = pymysql.connect(
        host=MYSQL_HOST, port=MYSQL_PORT,
        user=MYSQL_USER, password=MYSQL_PASSWORD,
        database=MYSQL_DB, charset="utf8mb4",
        autocommit=True,
        cursorclass=pymysql.cursors.DictCursor,
    )
    try:
        yield conn
    finally:
        conn.close()


def get_leave_balance(requester: str) -> dict | None:
    with get_conn() as conn:
        with conn.cursor() as cur:
            cur.execute(
                "SELECT annual_days, sick_days, personal_days FROM leave_balances WHERE requester=%s",
                (requester,)
            )
            return cur.fetchone()


def insert_leave_request(req: dict) -> str:
    """
    req expects keys: leave_id, requester, leave_type, start_time, end_time, duration_days, reason
    """
    with get_conn() as conn:
        with conn.cursor() as cur:
            cur.execute(
                """
                INSERT INTO leave_requests
                (leave_id, requester, leave_type, start_time, end_time, duration_days, reason, status)
                VALUES (%s,%s,%s,%s,%s,%s,%s,'PENDING')
                """,
                (
                    req["leave_id"], req["requester"], req["leave_type"],
                    req["start_time"], req["end_time"], req["duration_days"],
                    req.get("reason")
                )
            )
    return req["leave_id"]


def get_leave_request(leave_id: str) -> dict | None:
    with get_conn() as conn:
        with conn.cursor() as cur:
            cur.execute("SELECT * FROM leave_requests WHERE leave_id=%s", (leave_id,))
            return cur.fetchone()


def cancel_leave_request(leave_id: str) -> bool:
    with get_conn() as conn:
        with conn.cursor() as cur:
            cur.execute(
                "UPDATE leave_requests SET status='CANCELLED' WHERE leave_id=%s AND status='PENDING'",
                (leave_id,)
            )
            return cur.rowcount > 0



if __name__ == "__main__":
    print(get_conn())
    print(get_leave_request(leave_id="LV-12546613"))

```

## v4

修改之前的代码，使其支持redis

### 第一步

启动redis

```bash
$ sudo docker run --name some-redis -d -p 6379:6379 redis:7 redis-server --save 60 1 --loglevel warning
```

### 第二步

app/db/redis_session.py   建立redis的辅助文件

```python
import json
import redis
from typing import Any

r = redis.Redis(
    host="127.0.0.1",
    port=6379,
    decode_responses=True,
)

TTL_SECONDS = 604800  # 键多久会自动过期，此处是7天


DROP_KEYS = {"docs", "messages", "chat_history", "retrieved_docs"}
# 这是一个集合，集合中放的都是后面要存入redis的时候一些不要的键


def _safe_dumps(obj: Any) -> str:
    return json.dumps(obj, ensure_ascii=False, default=str)
# 上面是一个辅助函数，将一些对象转为str
# 主要是为了一些复杂对象如果没办法序列化而准备的
# 序列化就是将xx内容变成字节的序列，反序列化就是将字节序列再变回去
# ensure_ascii=False不要将中文等文字变成\0xFF这样的字节序列


def load_session(session_id: str) -> dict | None:
    s = r.get(session_id)  # 从redis中读取session_id这个键对应的值
    return json.loads(s) if s else None


def save_session(session_id: str, state: dict) -> None:
    safe_state = {k: v for k, v in state.items() if k not in DROP_KEYS}
    # 这一行其实是在过滤，去掉一些不想要的键值对，留下想要的存入redis
    r.setex(session_id, TTL_SECONDS, _safe_dumps(safe_state))
    # setex(键，过期时间，值)

```

### 第三步

app/main.py找到/chat handler

```python
from app.db.redis_session import load_session, save_session

class ChatResp(BaseModel):
    answer: str
    session_id: Optional[str] = None    # ⚠️添加
    active_route: Optional[str] = None  # ⚠️添加
    

```

修改chat

```python
@app.post("/chat", response_model=ChatResp)
def chat(req: ChatReq):
    payload = req.model_dump()
    text = payload.get("text") or payload.get("question") or ""

    # 1) get or create session id
    sid = payload.get("session_id") or f"sid-{uuid.uuid4().hex[:10]}"
    payload["session_id"] = sid

    # 2) load previous state from redis and merge
    prev_state = load_session(sid)
    if prev_state:
        merged = {**prev_state, **payload}
        merged["text"] = text
        payload = merged

    # 3) run router graph
    out = router_graph.invoke(payload)

    # 4) save new state to redis
    new_state = {**payload, **out}
    save_session(sid, new_state)

    return {
        "answer": out.get("answer"),
        "session_id": sid,
        "active_route": new_state.get("active_route"),
    }
```

测试4个cutl

```bash
curl -X POST http://127.0.0.1:8002/chat \
  -H "Content-Type: application/json" \
  -d '{"text":"我下周二想请一天年假","user_role":"public","requester":"peter"}'
```

得到下面json

```markdown
{"answer":"请确认你的请假信息：\n- 类型：annual\n- 开始：2025-11-28 09:00\n- 结束：2025-11-28 18:00\n- 时长：1.12 天\n- 原因：无\n回复“确认”提交，或直接回复修改后的信息。","session_id":"sid-52bdc79daf","active_route":"leave"}%
```

确认

```bash
curl -X POST http://127.0.0.1:8002/chat \
  -H "Content-Type: application/json" \
  -d '{"text":"确认","user_role":"public","requester":"peter","session_id":"sid-52bdc79daf"}'
```

查状态

```bash
curl -X POST http://127.0.0.1:8002/chat \
  -H "Content-Type: application/json" \
  -d '{"text":"查我的请假状态 LV-0b9880a8","user_role":"public","requester":"peter"}'
```

取消

```bash
curl -X POST http://127.0.0.1:8002/chat \
  -H "Content-Type: application/json" \
  -d '{"text":"取消请假申请 LV-0b9880a8","user_role":"public","requester":"peter"}'
```

再查一次状态

```bash
curl -X POST http://127.0.0.1:8002/chat \
  -H "Content-Type: application/json" \
  -d '{"text":"查我的请假状态 LV-0b9880a8","user_role":"public","requester":"peter"}'
```

最后mysql里看

```mysql
SELECT leave_id, requester, status, start_time, end_time
FROM leave_requests
ORDER BY id DESC
LIMIT 5;
```

## v6



# 知识储备

## rag

rag（Retrieval-Augmented Generation）中文名为检索增强生成，是结合信息检索与文本生成的技术框架。

它就像给大模型装了“外置知识库”，核心逻辑是大模型生成回答前，先从外部知识库检索相关信息，再结合检索结果和自身知识输出回复，以此解决大模型知识过期、易产生幻觉的问题 。比如智能客服用它检索最新产品售后政策，企业员工靠它查询内部制度文档，都能获得精准且有依据的结果 。



